<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>â˜•</text></svg>">
  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="resources/icon.png">
  <meta name="theme-color" content="#1d1712" media="(prefers-color-scheme: dark)">
  <meta name="theme-color" content="#e5e1db" media="(prefers-color-scheme: light)">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>fugue</title>
  <style>
    @font-face {
      font-family: 'Special Elite';
      src: url('resources/fonts/Special_Elite/SpecialElite-Regular.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
    }

    :root {
      --fade-duration: 10s;

      /* light mode */
      --parchment: #e5e1db;
      --vellum: #b5b1a8;
      --ink: #262629;

      /* dark mode */
      --bean: #1d1712;
      --roast: #16110d;
      --foam: #bfae94;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html {
      height: 100%;
      overflow: hidden;
      background: var(--bean);
    }

    body {
      height: 100%;
      overflow: hidden;
      background: linear-gradient(to bottom, var(--bean), var(--roast));
      color: var(--foam);
      font-family: 'Special Elite', monospace;
      font-size: 32px;
      line-height: 1.6;
      word-spacing: 0.3em;
      caret-color: transparent;
      cursor: none;
    }

    @media (prefers-color-scheme: light) {
      html {
        background: var(--parchment);
      }
      body {
        background: linear-gradient(to bottom, var(--parchment), var(--vellum));
        color: var(--ink);
      }
    }

    #writer {
      width: 100%;
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      padding: 0 2rem;
      position: absolute;
      top: 50%;
      transform: translateY(-100%);
      user-select: none;
    }

    @media (max-width: 600px) {
      body {
        font-size: 24px;
      }
      #writer {
        padding: 0 1rem;
      }
    }

    .line {
      white-space: pre-wrap;
      word-wrap: break-word;
      min-height: 1.6em;
      color: transparent;
    }

    .char {
      color: var(--foam);
      animation: fadeOut var(--fade-duration) ease-in-out forwards;
    }

    @keyframes fadeOut {
      from { opacity: 1; filter: blur(0px); }
      to { opacity: 0; filter: blur(2px); }
    }

    @keyframes fadeIn {
      from { opacity: 0; filter: blur(2px); }
      to { opacity: 1; filter: blur(0px); }
    }

    @media (prefers-color-scheme: light) {
      .char {
        color: var(--ink);
      }
    }

    #input {
      position: absolute;
      left: -9999px;
      opacity: 0;
    }

    @media print {
      html, body {
        height: auto;
        overflow: visible;
        font-size: 14pt;
        background: none;
      }
      #writer {
        position: static;
        transform: none;
        height: auto;
        padding: 0;
      }
      .line {
        color: #000 !important;
      }
      .line .char {
        opacity: 1 !important;
        filter: none !important;
        color: #000 !important;
        animation: none !important;
      }
      body > .char {
        display: none !important;
      }
    }
  </style>
</head>
<body>
  <div id="writer"></div>
  <textarea id="input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"></textarea>

  <script>
    const writer = document.getElementById('writer');
    const input = document.getElementById('input');
    const fadeDuration = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--fade-duration')) * 1000;
    let lines = [''];
    let lineElements = [];
    let fullText = '';
    let hasUserActivation = false;
    const activateUser = (e) => {
      if (e.type === 'keydown' && (e.metaKey || e.ctrlKey)) return;
      hasUserActivation = true;
    };
    document.addEventListener('click', activateUser);
    document.addEventListener('touchstart', activateUser);
    document.addEventListener('keydown', activateUser);

    let currentNotification = null;
    let notificationTimeout = null;
    function showNotification(message) {
      if (notificationTimeout) clearTimeout(notificationTimeout);
      if (currentNotification) {
        currentNotification.dataset.dismissing = '';
        currentNotification.style.animation = 'none';
        currentNotification.offsetHeight;
        currentNotification.style.opacity = '1';
        currentNotification.style.filter = 'blur(0px)';
        currentNotification.style.animation = 'fadeOut var(--fade-duration) ease-in-out forwards';
      } else {
        const notification = document.createElement('div');
        notification.className = 'char';
        notification.textContent = message;
        notification.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);text-align:center;white-space:pre-line;width:max-content;animation:fadeIn 0.2s ease-in-out forwards, fadeOut var(--fade-duration) ease-in-out 0.2s forwards;';
        document.body.appendChild(notification);
        currentNotification = notification;
      }
      const notification = currentNotification;
      notificationTimeout = setTimeout(() => {
        if (currentNotification === notification) {
          notification.remove();
          currentNotification = null;
        }
      }, fadeDuration + 200);
    }

    function createLine() {
      const line = document.createElement('div');
      line.className = 'line';
      writer.appendChild(line);
      lineElements.push(line);
      return line;
    }

    function getCurrentLine() {
      if (lineElements.length === 0) createLine();
      return lineElements[lineElements.length - 1];
    }

    function addChar(char) {
      const span = document.createElement('span');
      span.className = 'char';
      span.textContent = char;
      span.dataset.expires = Date.now() + fadeDuration;
      getCurrentLine().appendChild(span);
      setTimeout(() => span.replaceWith(char), fadeDuration);
    }

    function newLine() {
      lines.push('');
      const line = createLine();
      line.dataset.expires = Date.now() + fadeDuration;
    }

    function canDelete(el) {
      return el && Date.now() < parseInt(el.dataset.expires);
    }

    function deleteChar() {
      const currentLine = lineElements[lineElements.length - 1];
      const lastChar = currentLine?.lastElementChild;

      if (canDelete(lastChar)) {
        lastChar.remove();
        lines[lines.length - 1] = lines[lines.length - 1].slice(0, -1);
        fullText = fullText.slice(0, -1);
        input.value = fullText;
        return true;
      }

      if (lines.length > 1 && currentLine && !currentLine.hasChildNodes() && canDelete(currentLine)) {
        currentLine.remove();
        lineElements.pop();
        lines.pop();
        fullText = fullText.slice(0, -1);
        input.value = fullText;
        return true;
      }

      return false;
    }

    input.addEventListener('keydown', (e) => {
      if (e.key.startsWith('Arrow')) {
        e.preventDefault();
        return;
      }
      if (e.key === 'Backspace') {
        e.preventDefault();
        deleteChar();
        return;
      }
    });

    input.addEventListener('input', (e) => {
      const newText = input.value;
      if (newText.length < fullText.length) {
        input.value = fullText;
        return;
      }
      const added = newText.slice(fullText.length);

      if (currentNotification && !currentNotification.dataset.dismissing) {
        currentNotification.dataset.dismissing = 'true';
        currentNotification.style.animation = 'none';
        currentNotification.offsetHeight;
        currentNotification.style.animation = 'fadeOut 0.2s ease-in-out forwards';
        const notification = currentNotification;
        setTimeout(() => {
          if (currentNotification === notification) {
            notification.remove();
            currentNotification = null;
          }
        }, 200);
      }
      for (const char of added) {
        if (char === '\n') {
          newLine();
        } else {
          lines[lines.length - 1] += char;
          addChar(char);
        }
      }

      fullText = newText;
    });

    input.addEventListener('keydown', (e) => {
      if (e.key === 's' && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        const now = new Date();
        const pad = (n) => String(n).padStart(2, '0');
        const filename = `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}_${pad(now.getHours())}${pad(now.getMinutes())}.txt`;
        const blob = new Blob([fullText], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
      }
      if (e.key === 'o' && (e.metaKey || e.ctrlKey)) {
        e.preventDefault();
        if (!hasUserActivation) {
          showNotification('for security, browsers require page interaction before opening files.\ninteract with the page, then try again.');
          return;
        }
        if (fullText.length > 0) {
          if (!confirm('opening a file will replace your current text. continue?')) {
            return;
          }
        }
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = 'text/*,.txt,.md';
        fileInput.onchange = () => {
          const file = fileInput.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (e) => {
            const text = e.target.result;
            const importText = () => {
              writer.innerHTML = '';
              lines = [''];
              lineElements = [];
              fullText = '';
              const importedSpans = [];
              const fileLines = text.split('\n');
              fileLines.forEach((lineText, index) => {
                if (index > 0) {
                  lines.push('');
                  createLine();
                  fullText += '\n';
                }
                if (lineText.length > 0) {
                  const span = document.createElement('span');
                  span.className = 'char';
                  span.textContent = lineText;
                  span.style.animation = 'fadeIn 0.2s ease-in-out forwards';
                  getCurrentLine().appendChild(span);
                  importedSpans.push(span);
                  lines[lines.length - 1] += lineText;
                  fullText += lineText;
                }
              });
              input.value = fullText;
              setTimeout(() => {
                importedSpans.forEach(span => {
                  span.style.animation = 'fadeOut var(--fade-duration) ease-in-out forwards';
                  setTimeout(() => span.replaceWith(span.textContent), fadeDuration);
                });
              }, 200);
            };
            if (currentNotification) {
              if (notificationTimeout) clearTimeout(notificationTimeout);
              currentNotification.dataset.dismissing = 'true';
              currentNotification.style.animation = 'none';
              currentNotification.offsetHeight;
              currentNotification.style.animation = 'fadeOut 0.2s ease-in-out forwards';
              const notification = currentNotification;
              setTimeout(() => {
                notification.remove();
                if (currentNotification === notification) currentNotification = null;
                importText();
              }, 200);
            } else {
              importText();
            }
          };
          reader.readAsText(file);
        };
        fileInput.click();
      }
      // Disable cut, copy, paste, select all
      if ((e.metaKey || e.ctrlKey) && ['x', 'c', 'v', 'a'].includes(e.key.toLowerCase())) {
        e.preventDefault();
      }
    });

    // Also block via clipboard events
    ['cut', 'copy', 'paste'].forEach(event => {
      input.addEventListener(event, (e) => e.preventDefault());
    });

    window.addEventListener('beforeunload', (e) => {
      if (fullText.length > 0) {
        e.preventDefault();
      }
    });

    document.addEventListener('click', () => input.focus());
    input.focus();

    // Register service worker
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/sw.js');
    }
  </script>
</body>
</html>
